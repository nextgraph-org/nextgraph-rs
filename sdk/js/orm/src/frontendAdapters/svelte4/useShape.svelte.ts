// Copyright (c) 2025 Laurin Weger, Par le Peuple, NextGraph.org developers
// All rights reserved.
// Licensed under the Apache License, Version 2.0
// <LICENSE-APACHE2 or http://www.apache.org/licenses/LICENSE-2.0>
// or the MIT license <LICENSE-MIT or http://opensource.org/licenses/MIT>,
// at your option. All files in the project carrying such
// notice may not be copied, modified, or distributed except
// according to those terms.
// SPDX-License-Identifier: Apache-2.0 OR MIT

import { type Scope } from "../../types.ts";
import { onDestroy } from "svelte";
import type { BaseType, ShapeType } from "@ng-org/shex-orm";
import {
    useDeepSignal,
    type UseDeepSignalResult,
} from "@ng-org/alien-deepsignals/svelte4";
import { OrmSubscription } from "../../connector/ormSubscriptionHandler.ts";

export type { UseDeepSignalResult } from "@ng-org/alien-deepsignals/svelte4";

/** Extended result including the originating root signal wrapper from shape logic. */
export interface UseShapeRuneResult<T extends object>
    extends UseDeepSignalResult<T> {
    root: any;
}

/**
 * Svelte 3/4 hook to subscribe to RDF data in the graph database using a shape, see {@link ShapeType}.
 *
 * Returns a {@link DeepSignalSet} store containing the objects matching the shape and that are within the scope.
 * Establishes a 2-way binding: Modifications to the object are immediately committed,
 * changes coming from the backend (or other components) cause an immediate rerender.
 *
 * @param shape The {@link ShapeType} the objects should have (generated by the shex-orm tool).
 * @param scope The {@link Scope} in which the objects should be.
 * @returns A {@link DeepSignalSet} containing the objects matching the shape type and scope.
 *
 * @example
 * ```svelte
 * <script lang="ts">
 *     // Gets all expense objects with `@id` <s1 IRI> or <s2 IRI> and `@graph` <g1 IRI> or <g2 IRI>
 *     const expenses: DeepSignalSet<Expense> = useShape(ExpenseShape,
 *         {graphs: ["<g1 IRI>", "<g2 IRI>"],
 *         subjects: ["<s1 IRI>", "<s2 IRI>"]});
 *
 *     const expensesSorted = computed(() => expenses.sort((a, b) =>
 *         a.dateOfPurchase.localeCompare(b.dateOfPurchase)
 *     ));
 *
 *     // Call expenses.add({"@graph": "<g1 or g2 IRI>", "@id": "", title: "Example title"}), to add new elements.
 *     // Leave `@id` an empty string to auto-generate a subject IRI (adjust your scope accordingly).
 *
 *     // Not that if you use `@id` (the subject IRI) as key, you need to ensure that it is unique within your scope.
 *     // If it is not, use the combination of `@graph` and `@id`.
 * </script>
 *
 * <section>
 *     <div>
 *         {# if expensesSorted.length === 0}
 *         <p>
 *             No expense yet.
 *         </p>
 *         {:else}
 *         {#each expensesSorted as expense, index (expense['@id']) }
 *             <ExpenseCard
 *             expense={expense}
 *             />
 *         {/each}
 *         {/if}
 *     </div>
 * </section>
 * ```
 *
 * ---
 * In the ExpenseCard component:
 * ```svelte
 *
 *   let {
 *     expense = $bindable(),
 *   }: { expense: Expense; } = $props();
 * </script>
 *
 * <div>
 *   <input
 *     value={expense.title ?? ""}
 *     oninput={(event) => {expense.title = event.currentTarget!.value}}
 *     placeholder="Expense title"
 *   />
 * </div>
 * ```
 */
export function useShape<T extends BaseType>(
    shape: ShapeType<T>,
    scope: Scope
): UseShapeRuneResult<Set<T>> {
    const { signalObject: rootSignal, close } = OrmSubscription.getOrCreate(
        shape,
        scope
    );

    onDestroy(close);

    const ds = useDeepSignal<Set<T>>(rootSignal as Set<T>);
    return { root: rootSignal, ...ds } as UseShapeRuneResult<Set<T>>;
}

export default useShape;
