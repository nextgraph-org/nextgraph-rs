// Copyright (c) 2025 Laurin Weger, Par le Peuple, NextGraph.org developers
// All rights reserved.
// Licensed under the Apache License, Version 2.0
// <LICENSE-APACHE2 or http://www.apache.org/licenses/LICENSE-2.0>
// or the MIT license <LICENSE-MIT or http://opensource.org/licenses/MIT>,
// at your option. All files in the project carrying such
// notice may not be copied, modified, or distributed except
// according to those terms.
// SPDX-License-Identifier: Apache-2.0 OR MIT

import type { BaseType } from "@ng-org/shex-orm";
import { useDeepSignal } from "@ng-org/alien-deepsignals/react";
import type { ShapeType } from "@ng-org/shex-orm";
import { useEffect, useMemo, useRef } from "react";
import type { Scope } from "../../types.ts";
import { OrmConnection } from "../../connector/ormConnectionHandler.ts";
import { DeepSignalSet } from "@ng-org/alien-deepsignals";

/**
 * Hook to subscribe to RDF data in the graph database using a shape, see {@link ShapeType}.
 * 
 * Returns a {@link DeepSignalSet} of objects matching the shape and that are within the scope.
 * Establishes a 2-way binding: Modifications to the object are immediately committed,
 * changes coming from the backend (or other components) cause an immediate rerender.
 *
 * @param shape The {@link ShapeType} the objects should have (generated by the shex-orm tool).
 * @param scope The {@link Scope} as graph, array of graphs or scope object with graphs and subjects.
 * @returns A deep {@link DeepSignalSet} with the orm objects or an empty set, if still loading.\
 *          If the scope is explicitly set to `undefined`, an empty set is returned which errors
 *          if you try to make modifications on it.
 * 
 * @example
 ```tsx
function Expenses() {
    const expenses = useShape(ExpenseShapeType, {graphs: ["<graph IRI>"]});

    const createExpense = useCallback(
        () => {
            expenses.add({
                "@graph": `<graph IRI>`,
                "@type": "http://example.org/Expense",
                "@id": "", // Assigns id automatically, if set to "".
                title: "New expense",
                dateOfPurchase: obj.dateOfPurchase ?? new Date().toISOString(),
            });
        },
        [expenses]
    );

    const expensesSorted = [...expenses].sort((a, b) =>
        a.dateOfPurchase.localeCompare(b.dateOfPurchase)
    );

    // Not that if you use `@id` (the subject IRI) as key, you need to ensure that it is unique within your scope.
    // If it is not, use the combination of `@graph` and `@id`.
    
    return (
        <div>
            <button
                onClick={() => createExpense({})}
            >
                + Add expense
            </button>
            <div>
                {expensesSorted.length === 0 ? (
                    <p>
                        No expenses yet.
                    </p>
                ) : (
                    expensesSorted.map((expense) => (
                        <ExpenseCard
                            key={expense["@id"]}
                            expense={expense}
                            availableCategories={expenseCategories}
                        />
                    ))
                )}
            </div>
        </div>
    );
}
```
 */
const useShape = <T extends BaseType>(
    shape: ShapeType<T>,
    scope: Scope | string[] | string = {}
) => {
    const parsedScope =
        typeof scope === "string"
            ? { graphs: [scope] }
            : Array.isArray(scope)
              ? { graphs: scope }
              : scope;

    const prevOrmConnection = useRef<undefined | OrmConnection<T>>(undefined);

    const ormConnection = useMemo(() => {
        if (scope === undefined) return undefined;
        if (prevOrmConnection.current) prevOrmConnection.current.close();
        const newOrmConnection = OrmConnection.getOrCreate(shape, parsedScope);
        prevOrmConnection.current = newOrmConnection;
        return newOrmConnection;
    }, [shape, scope, parsedScope.graphs, parsedScope.subjects]);

    useEffect(() => {
        if (!ormConnection) return;

        return () => {
            ormConnection.close();
        };
    }, [ormConnection]);

    const state = useDeepSignal(ormConnection?.signalObject ?? readOnlySet);

    return state as DeepSignalSet<T>;
};

const readOnlySet = new Proxy(new Set(), {
    get(target, key, receiver) {
        if (key === "add" || key === "delete" || key === "clear") {
            return () => {
                throw new Error("Set is readonly because scope is empty.");
            };
        }
        const value = (target as any)[key];
        if (typeof value === "function") {
            return value.bind(target);
        }
        return value;
    },
});

export default useShape;
