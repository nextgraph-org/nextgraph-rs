// Copyright (c) 2025 Laurin Weger, Par le Peuple, NextGraph.org developers
// All rights reserved.
// Licensed under the Apache License, Version 2.0
// <LICENSE-APACHE2 or http://www.apache.org/licenses/LICENSE-2.0>
// or the MIT license <LICENSE-MIT or http://opensource.org/licenses/MIT>,
// at your option. All files in the project carrying such
// notice may not be copied, modified, or distributed except
// according to those terms.
// SPDX-License-Identifier: Apache-2.0 OR MIT

import { normalizeScope, type Scope } from "../../types.ts";
import { onDestroy } from "svelte";
import type { BaseType, ShapeType } from "@ng-org/shex-orm";
import {
    useDeepSignal,
    type UseDeepSignalResult,
} from "@ng-org/alien-deepsignals/svelte";
import { OrmConnection } from "../../connector/ormConnectionHandler.ts";

export type { UseDeepSignalResult } from "@ng-org/alien-deepsignals/svelte";

/** Extended result including the originating root signal wrapper from shape logic. */
export interface UseShapeRuneResult<T extends object>
    extends UseDeepSignalResult<T> {
    root: any;
}

/**
 * Svelte 5 hook to subscribe to RDF data in the graph database using a shape, see {@link ShapeType}.
 *
 * Returns a {@link DeepSignalSet} that contain the objects matching the shape and that are within the scope.
 * Establishes a 2-way binding: Modifications to the object are immediately committed,
 * changes coming from the engine (or other components) cause an immediate rerender.
 *
 * @param shape The {@link ShapeType} the objects should have (generated by the `@ng-org/shex-orm` tool).
 * @param scope The {@link Scope} in which the objects should be.
 * @returns A {@link DeepSignalSet} containing the objects matching the shape type and scope.
 *
 * @example
 * ```svelte
 * <script lang="ts">
 *     // Gets all expense objects with `@id` <s1 IRI> or <s2 IRI> and `@graph` <g1 IRI> or <g2 IRI>
 *     const expenses: DeepSignalSet<Expense> = useShape(ExpenseShapeType,
 *         {graphs: ["<g1 IRI>", "<g2 IRI>"],
 *         subjects: ["<s1 IRI>", "<s2 IRI>"]});
 *
 *     const expensesSorted = computed(() => expenses.sort((a, b) =>
 *         a.dateOfPurchase.localeCompare(b.dateOfPurchase)
 *     ));
 *
 *     const createExpense = () => {
 *         expenses.add({
 *             "@graph": `<graph IRI>`,
 *             "@type": "http://example.org/Expense",
 *             "@id": "", // Assigns id automatically, if set to "".
 *             title: "New expense",
 *             dateOfPurchase: obj.dateOfPurchase ?? new Date().toISOString(),
 *         });
 *     };
 *
 *
 *     // Note that if you use `@id` (the subject IRI) as key, you need to ensure that it is unique within your scope.
 *     // If it is not, use the combination of `@graph` and `@id`.
 * </script>
 *
 * <section>
 *     <div>
 *         <button on:click={() => createExpense()}>
 *             + Add expense
 *         </button>
 *
 *         {# if expensesSorted.length === 0}
 *             <p>
 *                 No expense yet.
 *             </p>
 *         {:else}
 *             {#each expensesSorted as expense, index (expense['@id']) }
 *                 <ExpenseCard
 *                 expense={expense}
 *                 />
 *             {/each}
 *         {/if}
 *     </div>
 * </section>
 * ```
 *
 * ---
 * In the ExpenseCard component:
 * ```svelte
 * <script lang="ts">
 * let {
 *     expense,
 * }: { expense: DeepSignal<Expense>; } = $props();
 * </script>
 *
 * <div>
 *     <input
 *         value={expense.title ?? ""}
 *         oninput={(event) => {expense.title = event.currentTarget.value}}
 *     />
 * </div>
 * ```
 */
export function useShape<T extends BaseType>(
    shape: ShapeType<T>,
    scope: Scope
) {
    const { signalObject: rootSignal, close } = OrmConnection.getOrCreate(
        shape,
        scope
    );

    onDestroy(close);

    const shapeSignalSet = useDeepSignal<Set<T>>(rootSignal as Set<T>);
    return shapeSignalSet;
}

export default useShape;
